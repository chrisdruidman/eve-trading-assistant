{
  "enabled": true,
  "name": "Auto Git Commit on Task Completion",
  "description": "Automatically creates git commits when tasks are completed or when significant code changes are made, ensuring proper version control throughout development",
  "version": "2",
  "when": {
    "type": "fileEdited",
    "patterns": [
      "**/tasks.md",
      "**/*.ts",
      "**/*.js",
      "**/*.tsx",
      "**/*.jsx",
      "**/*.json",
      "**/package.json",
      "**/Dockerfile",
      "**/*.sql"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "A file has been modified that may indicate task completion or significant development progress. Please:\n\n1. Check if there are uncommitted changes: `git status --porcelain`\n2. If this appears to be task completion (tasks.md was modified), check what task was completed\n3. If there are uncommitted changes, create an appropriate commit:\n   - For task completion: Use format 'feat: [task-id] - [description]' with details about what was implemented\n   - For code changes: Use format 'feat: [component] - [description]' or 'fix: [component] - [description]'\n   - For infrastructure: Use format 'chore: [description]' for config/setup changes\n\n4. Stage all changes: `git add .`\n5. Commit with descriptive message following the format above\n6. Push to current branch: `git push origin $(git branch --show-current) 2>/dev/null || echo \"Push failed or no remote configured\"`\n\nIMPORTANT: Use ONLY non-interactive git commands. Never use commands that wait for user input like `git diff` without --no-pager, or interactive rebase. If you need to check differences, use `git diff --name-only` or `git status --porcelain`. Only perform git operations if there are actual uncommitted changes."
  }
}